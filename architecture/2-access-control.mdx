---
title: "Access Control"
description: "Description of your new file."
---

Sage Protocol implements a secure, type-safe, witness-based access control system built using the Sui Move language. This system ensures sensitive operations within the protocol are restricted to explicitly authorized components, significantly enhancing security, flexibility, and composability.

### Configurable Witness Pattern

 At the heart of Sage’s access control lies the configurable witness pattern. Witnesses function as special authorization tokens required to perform protected actions. Each witness is associated with a configuration object that explicitly specifies which witness types are authorized.

For example, the following function ensures that only authorized witness types are permitted at runtime:

```rust
public fun verify_channel_witness<ChannelWitnessType: drop>(
    channel_witness_config: &ChannelWitnessConfig,
    _: &ChannelWitnessType
): bool {
    let type_name = type_name::get<ChannelWitnessType>();
    type_name == channel_witness_config.type_name
}
```

This explicit type-name check prevents unauthorized witness usage, significantly strengthening protocol security.

### **Architectural Levels of Access Control**

Sage’s access control framework is structured into multiple clear layers:

- **Witness Configurations (Cross-Package Validation):**
  - `ChannelWitnessConfig`, `UserWitnessConfig`, `GroupWitnessConfig`: Define allowed witness types for user and channel interactions.
  - `GovernanceWitnessConfig`, `RewardWitnessConfig`: Secure critical administrative actions involving governance and reward management. These configurations are explicitly designed to become immutable after initial deployment, ensuring transparency and decentralized control.
- **Administrative Capabilities:**
  - `AdminCap`, `FeeCap`, `RewardCap`, `InviteCap`, `MintCap`: Specialized permissions explicitly granting administrative privileges for sensitive protocol management tasks.
- **Object-Level Permissions:**
  - `UserOwnedConfig`, `UserSharedConfig`: Clearly enforce permissions at the object level, ensuring users can modify only data they own or explicitly share.

### **Security Advantages**

This witness-based model offers several important benefits:

- **Runtime Type Safety:**\
  Explicit type-name checks catch unauthorized access attempts immediately at runtime, reducing risk from misconfiguration or unauthorized actions.
- **Composable Security:**\
  Sage can readily introduce new witness types and validation rules, integrating seamlessly into the existing security framework.
- **Upgradeable and Flexible:**\
  Administrative capabilities permit updating witness configurations securely at runtime, eliminating the need to redeploy smart contracts. For example, administrators can securely update governance witness configurations using existing admin permissions:

```
public fun update_governance_witness<TypeName>(
    _: &AdminCap,
    governance_witness_config: &mut GovernanceWitnessConfig
) {
    assert!(!governance_witness_config.finalized, EIsFinalized);
    governance_witness_config.type_name = type_name::get<TypeName>();
    governance_witness_config.finalized = true;
}
```

This ensures adaptability for future upgrades, reducing both overhead and risk associated with configuration updates.